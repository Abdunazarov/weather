# Weather App
## Особенности

- **Использование Poetry**: Управление зависимостями проекта с помощью инструментария Poetry для Python.
- **Кэширование на базе Python**: Улучшенная производительность за счет кэширования данных о погоде.
- **Оптимизация запросов**: Сокращение количества обращений к внешним API, благодаря интеллектуальному кэшированию.
- **Структурированный код**: Чистая архитектура и хорошо структурированный код Flask-приложения.

## Начало работы

## Клонирование приложения
```bash
git clone https://github.com/Abdunazarov/weather.git
```

### Предварительные требования

Перед началом работы убедитесь, что у вас установлены `python` и `poetry`.

```sh
pip install poetry
```

### Установка

Для установки зависимостей, миграции данных и запуска проекта выполните следующие команды:

```bash
poetry install
flask db upgrade
```

## Использование

### Запуск приложения `update: 03/03/24`
При установке зависимостей установится новый Gunicorn, наш WSGI сервер, на котором мы запустим наше приложение, вместо веб-сервера Flask, который идет в комплекте по умолчанию.

```bash
gunicorn -w 2 run:app --log-level DEBUG
```
В данном случае мы запускаем 2 воркера, которые будут обрабатывать запросы параллельно. Это число можно увеличить в зависимости от спецификации устройства. (Формула оптимального количества воркеров: `2 * num_cores + 1`, где `num_cores` — количество ядер процессора.)

Для демонстрации работоспособности приложения на Gunicorn и того, что два воркера, которых мы запустили, действительно работают параллельно, я создал два тестовых эндпоинта - GET /endpoint-1 и GET /endpoint-2, в которых прописан `sleep(5)`. Чтобы увидеть, что воркеры параллельно обрабатывают запросы, нужно на Linux устройствах выполнить следующую команду:

```bash
echo http://localhost:8000/endpoint-1 http://localhost:8000/endpoint-2 | xargs -n 1 -P 2 curl
```

Это выполнит параллельные запросы на наши тестовые эндпоинты, для визуальной демонстрации работы. В итоге, мы получим ответ одновременно, так как, несмотря на то что методы "спали" по 5 секунд, ответ на два эндпоинта мы получили за примерно 5 секунд.


### Создание пользователя

Чтобы создать нового пользователя, отправьте POST-запрос на `/create-user` с JSON-телом, содержащим `username` и `balance`. (При миграции данных создаются 5 пользователей)

```http
POST /create-user
Content-Type: application/json

{
  "username": "newuser",
  "balance": 10000
}
```

### Обновление баланса

Для обновления баланса пользователя по текущей температуре в городе, отправьте POST-запрос на `/update-balance`.

```http
POST /update-balance
Content-Type: application/json

{
  "userId": 1,
  "city": "Moscow"
}
```

### Удаление пользователя

Чтобы удалить пользователя, отправьте DELETE-запрос на `/delete-user/<id>`.

```http
DELETE /delete-user/1
```
